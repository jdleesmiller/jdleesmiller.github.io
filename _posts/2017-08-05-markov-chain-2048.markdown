---
layout: post
title: "Markov Chains for 2048"
date: 2017-08-05 09:00:00 +0000
categories: articles
---

<img src="/assets/2048/2048.png" alt="Screenshot of 2048" style="width: 40%; float: right; margin-left: 10pt; border: 6pt solid #eee;"/>

For several months in early 2014, everyone was addicted to [2048](http://gabrielecirulli.github.io/2048). Like the Rubik's cube, it is a very simple game, and yet it is very compelling. It seems to strike the right balance along so many dimensions --- not too easy but not too hard; not too predictable but comfortingly familiar; not too demanding but still absorbing.

To better understand what makes the game work so well, I have been trying to analyze it mathematically. In this first post of what will be a series, we will develop a model of the 2048 as a Markov Chain. Using this model, we'll show that:

1. It takes at least 940 moves on average to win.

1. The distribution of the number of moves to win is closely related to the binomial distribution.

1. The 4x4 board is the smallest board on which you can reach the 2048 tile.

## The Name of the Game

Let's start with a recap of the rules of the game.

2048 is played on a board with 16 cells arranged in a 4x4 grid. Each cell can be empty or can contain a tile with a value that is a power of 2 between 2 and 2048, namely 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 or 2048.

The player moves `left`, `right`, `up` or `down`, and all of the tiles slide as far as possible in that direction. If two tiles with the same value slide together, they merge into a single tile with twice that value. For example, if two `8` tiles merge, the result is a single `16` tile.

Twice at the beginning of the game and then after each move, the game places a random tile on the board. We can see exactly how by [reading the game's source code](https://github.com/gabrielecirulli/2048): it selects an empty cell uniformly at random and then places there a `2` tile with probability 0.9 or a `4` tile with probability 0.1. The game therefore starts with two randomly placed tiles on the board, each of which is either a `2` or a `4`.

The game continues until either (a) a `2048` tile is obtained, in which case the player wins, or (b) the board is full and it is not possible to move any tile, in which case the player loses. The game will let you play past the `2048` tile, but for now we'll restrict our attention to the primary objective, which is to reach the `2048` tile.

## The Bag Process

It's quite complicated to model all of that, so we'll start with a much simpler game in which we just throw the tiles into a bag instead of placing them on a board. It is much less fun, but we'll see that this bag process still preserves some important properties of the real game.

The bag process can be described with just two operations:

- *Add Tile*: Put a new tile in the bag where, just like in the real game, the new tile has either value `2`, with probability 0.9, or value `4`, with probability 0.1.

- *Merge Tiles*: Find all of the pairs of tiles in the bag that have the same value and remove them; then replace each pair of tiles with a single tile with twice the value.

Unlike in the real game, where we can only merge tiles that are adjacent on the board, the bag process lets us merge any tiles that we like. Also unlike in the real game, there are no decisions to make; the process just proceeds on its own. In particular, it evolves as follows:

1. Start with an empty bag.

2. Perform the *Add Tile* operation twice, to simulate adding the two initial tiles.

3. Perform the *Merge Tiles* operation.

4. Perform the *Add Tile* operation once.

5. If the bag contains a tile with value 2048, we've won. Otherwise, go back to step 3.

This is the sort of thing we can model as a Markov Chain. In particular, it is a discrete time absorbing Markov chain.

It is probably best seen from a picture. Here are the first few layers:

<p align="center">
<img src="/assets/2048/markov_chain_0.svg" alt="TODO" />
</p>

<p align="center">
<img src="/assets/2048/markov_chain_1.svg" alt="TODO" />
</p>

One consequence of this is that it's not possible to lose, because there's no constraint on the bag size.

Sum of tiles in the bag increases by either 2 or 4 on each transition (after the first one).

To model 2048 as a Markov Chain, the first simplification we'll make is to collapse the board into a list.

What's interesting?

- Picture of the Markov Chain.

- Distribution of the number of moves.

- Results for absorbing Markov chains.

- Connection with the binomial model.

<style>

.node circle {
  fill: #999;
}

.node text {
  font: 10px sans-serif;
}

.node--internal circle {
  fill: #555;
}

.node--internal text {
  text-shadow: 0 1px 0 #fff, 0 -1px 0 #fff, 1px 0 0 #fff, -1px 0 0 #fff;
}

.link {
  fill: none;
  stroke: #555;
  stroke-opacity: 0.4;
  stroke-width: 1.5px;
}

</style>

<div id="container" style="width: 100%; overflow: scroll;">
  <svg></svg>
  <!-- <canvas></canvas> -->
</div>
<script src="/assets/d3/d3.v4.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.4/lodash.min.js"></script>
<script type="text/javascript">

(function () {
  var NODE_HEIGHT = 20;
  var LAYER_WIDTH = 60;

  var svg = d3.select('svg')
  var g = svg.append('g')

  function convertTransitionsToGraph (transitions) {
    var nodes = {}
    var links = []

    function addNode (stateString) {
      var state = JSON.parse(stateString)
      var id = '{' + state.join(', ') + '}'
      if (nodes.hasOwnProperty(id)) return id
      nodes[id] = {
        id: id,
        state: state,
        sum: _.sum(state),
        size: state.length
      }
      return id
    }

    _.forIn(transitions, function (successors, node0) {
      var id0 = addNode(node0)
      _.forIn(successors, function (pr, node1) {
        var id1 = addNode(node1)
        links.push({ source: id0, target: id1, pr: pr })
      })
    })

    return { nodes: nodes, links: links }
  }

  // idea...
  // probably have to hard code the first few
  // maybe do a greedy optimization where we fix each layer as we go but
  // calculate the minimum-crossing solution for the next layer.
  //
  // In most cases, n! would be OK, but we have n=20 for one, so that's out. 
  // What if we just generate the successors in order?

  function layoutNodesInLayer (nodes, _sum) {
    // 1 -> 0; 2 -> 0, 1; 3 -> -1, 0, 1; 4 -> -1, 0, 1, 2, etc.
    var offset = -Math.floor((nodes.length - 1) / 2)
    _(nodes).sortBy('size').reverse().each(function (node, index) {
      node.x = Math.max(0, node.sum - 2) * LAYER_WIDTH
      var y;
      if (node.sum == 4) {
        y = 1
      } else if (node.sum == 6) {
        y = -1
      } else {
        y = offset + index
      }
      node.y = y * NODE_HEIGHT
    })
  }

  function layoutNodes (nodes) {
    _(nodes).values().groupBy('sum').each(layoutNodesInLayer)
  }

  function getExtent (nodes, dimension) {
    var values = _(nodes).values().map(dimension)
    return values.max() - values.min()
  }

  function centerNodes (nodes, height) {
    _(nodes).each(function (node) { node.y += height / 2 })
  }

  d3.json("/assets/2048/transitions_11.json", function (err, data) {
    if (err) throw err

    var graph = convertTransitionsToGraph(data)
    layoutNodes(graph.nodes)

    var width = getExtent(graph.nodes, 'x') + LAYER_WIDTH;
    svg.attr('width', width)

    var height = getExtent(graph.nodes, 'y') + 2 * NODE_HEIGHT;
    svg.attr('height', height)

    centerNodes(graph.nodes, height)

    var node = g
      .selectAll('.node')
      .data(_.values(graph.nodes))
      .enter().append('g')

    node.attr('class', function (d) { return 'node' })
    node.attr('transform', function (d) {
      return 'translate(' + d.x + ',' + d.y + ')'
    })

    node.append('text')
      .attr('dy', 3)
      .attr('x', function(d) { return 8 })
      .text(function(d) { return d.id })

    var link = g
      .selectAll('.link')
      .data(graph.links)
      .enter().append('path')

    link.attr("class", "link")
    link.attr("d", function(d) {
      var source = graph.nodes[d.source]
      var target = graph.nodes[d.target]
      return "M" + target.x + "," + target.y
          + "C" + (source.x + 100) + "," + target.y
          + " " + (source.x + 100) + "," + source.y
          + " " + source.x + "," + source.y;
    });
  })
})()


// (function () {
//   var LAYER_SPACING = 30
// 
//   function convertTransitionsToD3Graph (transitions) {
//     var nodes = {}
//     var links = []
// 
//     function addNode (node) {
//       var state = JSON.parse(node)
//       var id = state.join(', ')
//       var stateSum = _.sum(state);
//       if (nodes.hasOwnProperty(id)) return id
//       nodes[id] = {
//         id: id,
//         fx: LAYER_SPACING * stateSum / 2
//       }
//       return id
//     }
// 
//     _.forIn(transitions, function (successors, node0) {
//       var id0 = addNode(node0)
//       _.forIn(successors, function (pr, node1) {
//         var id1 = addNode(node1)
//         links.push({ source: id0, target: id1, pr: pr })
//       })
//     })
// 
//     return { nodes: _.values(nodes), links: links }
//   }
// 
//   var container = document.getElementById('container')
//   var canvas = document.querySelector('canvas')
// 
//   var simulation = d3.forceSimulation()
//     .force('link',
//       d3.forceLink()
//         .id(function(d) { return d.id; })
//         .strength(function(d) { return d.pr; }))
//     .force('charge',
//       d3.forceManyBody()
//         .strength(function () { return -10; }))
// 
//   d3.json("/assets/2048/transitions_11.json", function (err, data) {
//     if (err) throw err
// 
//     var graph = convertTransitionsToD3Graph(data)
// 
//     var width = _(graph.nodes).map('fx').max()
//     var height = container.offsetHeight
// 
//     canvas.width = width
//     canvas.height = height
//     var context = canvas.getContext('2d')
// 
//     simulation.force('center', d3.forceCenter(width / 2, height / 2))
//     simulation.force('y',
//       d3.forceY()
//         .y(function () { return height / 2 })
//         .strength(function () { return 0.1 }))
// 
//     function ticked() {
//       context.clearRect(0, 0, width, height);
// 
//       context.beginPath();
//       graph.links.forEach(drawLink);
//       context.strokeStyle = "#aaa";
//       context.stroke();
// 
//       context.beginPath();
//       graph.nodes.forEach(drawNode);
//       context.fill();
//       context.strokeStyle = "#fff";
//       context.stroke();
//     }
// 
//     function drawLink(d) {
//       context.moveTo(d.source.x, d.source.y);
//       context.lineTo(d.target.x, d.target.y);
//     }
// 
//     function drawNode(d) {
//       context.moveTo(d.x + 3, d.y);
//       context.arc(d.x, d.y, 3, 0, 2 * Math.PI);
//     }
//     
//     simulation.nodes(graph.nodes).on('tick', ticked)
// 
//     simulation.force('link').links(graph.links)
//   })
// })()


// var svg = d3.select("svg"),
//     width = +svg.attr("width"),
//     height = +svg.attr("height"),
//     g = svg.append("g").attr("transform", "translate(40,0)");
// 
// var tree = d3.cluster()
//     .size([height, width - 160]);
// 
// var stratify = d3.stratify()
//     .parentId(function(d) { return d.id.substring(0, d.id.lastIndexOf(".")); });
// 
// d3.csv("/assets/2048/flare.csv", function(error, data) {
//   if (error) throw error;
// 
//   var root = stratify(data)
//       .sort(function(a, b) { return (a.height - b.height) || a.id.localeCompare(b.id); });
// 
//   tree(root);
// 
//   var link = g.selectAll(".link")
//       .data(root.descendants().slice(1))
//     .enter().append("path")
//       .attr("class", "link")
//       .attr("d", function(d) {
//         return "M" + d.y + "," + d.x
//             + "C" + (d.parent.y + 100) + "," + d.x
//             + " " + (d.parent.y + 100) + "," + d.parent.x
//             + " " + d.parent.y + "," + d.parent.x;
//       });
// 
//   var node = g.selectAll(".node")
//       .data(root.descendants())
//     .enter().append("g")
//       .attr("class", function(d) { return "node" + (d.children ? " node--internal" : " node--leaf"); })
//       .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; })
// 
//   node.append("circle")
//       .attr("r", 2.5);
// 
//   node.append("text")
//       .attr("dy", 3)
//       .attr("x", function(d) { return d.children ? -8 : 8; })
//       .style("text-anchor", function(d) { return d.children ? "end" : "start"; })
//       .text(function(d) { return d.id.substring(d.id.lastIndexOf(".") + 1); });
// });

</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
 
